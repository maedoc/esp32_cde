# Comprehensive Guide to Unit Testing with ESP-IDF, Unity, and QEMU

This guide explains how to create, build, and run unit tests for Kumo components using the Unity test framework and QEMU emulator.

## 1. Overview

The testing infrastructure allows you to:
-   **Isolate Components:** Test specific logic within a component without needing the full system.
-   **Mock Dependencies:** Use CMock to simulate the behavior of other components or hardware drivers.
-   **Run fast in QEMU:** Execute tests in an emulated environment (ESP32-C3) without flashing physical hardware.

## 2. Directory Structure

To add tests to a component (e.g., `components/my_component`), follow this structure:

```text
components/my_component/
├── CMakeLists.txt          # Main component build file
├── include/
│   └── my_component.h
├── my_component.c
└── test/                   # Test directory
    ├── CMakeLists.txt      # Test component build file
    └── test_my_component.c # Test source code
```

## 3. Creating a New Test

### Step 1: Create the Test Directory and File

Create `components/my_component/test/test_my_component.c`.

```c
#include "unity.h"
#include "my_component.h"

// Optional: Include mock headers if needed
// #include "mock_other_component.h"

void setUp(void) {
    // Run before each test
}

void tearDown(void) {
    // Run after each test
}

TEST_CASE("my_component initialization success", "[my_component]") {
    // Arrange
    config_t config = { .enable = true };

    // Act
    esp_err_t err = my_component_init(&config);

    // Assert
    TEST_ASSERT_EQUAL(ESP_OK, err);
}

TEST_CASE("my_component handles null config", "[my_component]") {
    // Act
    esp_err_t err = my_component_init(NULL);

    // Assert
    TEST_ASSERT_EQUAL(ESP_ERR_INVALID_ARG, err);
}
```

### Step 2: Configure CMake for the Test

Create `components/my_component/test/CMakeLists.txt`. This is **crucial** because it tells the build system this directory is a "test component" that requires the main component and the Unity framework.

```cmake
# components/my_component/test/CMakeLists.txt

idf_component_register(
    SRCS "test_my_component.c"
    INCLUDE_DIRS "."
    REQUIRES unity my_component
    # Add cmock if you need mocking:
    # REQUIRES unity my_component cmock
)
```

### Step 3: Register the Component for Testing

Open `test/CMakeLists.txt` (in the root `test` directory, not the component's) and add your component's name to the `TEST_COMPONENTS` list.

```cmake
# test/CMakeLists.txt

set(TEST_COMPONENTS
    "kmbus"
    "can_twai"
    # ...
    "my_component" # <--- ADD THIS
    "can_kumo"
)
```

## 4. Building and Running Tests (QEMU)

The project uses a dedicated test runner script that wraps QEMU.

### Prerequisites
-   Ensure you are in the project root.
-   Ensure your ESP-IDF environment is active (`. $IDF_PATH/export.sh`).

### Method A: The Runner Script (Recommended)

Use `test/qemu-test.sh` for easy interaction.

1.  **Build and List Tests:**
    This will compile the test firmware (`build/kmtest.bin`) and list all available test cases.
    ```bash
    ./test/qemu-test.sh list
    ```
    *Output Example:*
    ```text
    (1) "my_component initialization success" [my_component]
    (2) "my_component handles null config" [my_component]
    ```

2.  **Run a Specific Test:**
    Use the ID number from the list command.
    ```bash
    ./test/qemu-test.sh 1
    ```

### Method B: The Python Runner (Advanced)

For running all tests or integrating with CI, use `test/runner.py`.

1.  **Run All Tests:**
    ```bash
    python3 test/runner.py run --all
    ```

2.  **Run Specific Tests by ID:**
    ```bash
    python3 test/runner.py run 1 2 5
    ```

## 5. Mocking with CMock

If your component depends on another component (e.g., `kmbus`), you often want to mock that dependency to test your component in isolation.

1.  **Add `cmock` to Requirements:**
    In `components/my_component/test/CMakeLists.txt`:
    ```cmake
    REQUIRES unity my_component cmock
    ```

2.  **Include the Mock Header:**
    CMock automatically generates mocks for headers it finds. If you want to mock `kmbus.h`, include `mock_kmbus.h` in your test file.

    ```c
    #include "unity.h"
    #include "my_component.h"
    #include "mock_kmbus.h" // Generated by CMock

    TEST_CASE("send message via kmbus", "[my_component]") {
        // Expect kmbus_send to be called once with any arguments and return ESP_OK
        kmbus_send_ExpectAnyArgsAndReturn(ESP_OK);

        my_component_send_data(0x123);
    }
    ```

    *Note: The exact generation of mocks depends on the project's CMock configuration. If `mock_header.h` isn't found, check if the header is properly exposed in the dependency's `include` directory.*

## 6. Troubleshooting

-   **"File not found":** Ensure you added your component to `TEST_COMPONENTS` in `test/CMakeLists.txt`.
-   **Linker Errors:** Check your `REQUIRES` list in `components/my_component/test/CMakeLists.txt`. You must explicitly require the component you are testing.
-   **QEMU Hangs:** The runner has a timeout (default 60s). If your test loops forever, it will eventually fail. Use `ctrl+c` to abort.
-   **Flash/Efuse Errors:** The runner creates temporary bin files (`/tmp/kumo-*-flash.bin`). Ensure you have write permissions to `/tmp`.

## 7. Running on Real Hardware

While QEMU is great for logic, sometimes you need hardware.

1.  **Build and Flash:**
    ```bash
    idf.py -p test -b 2000000 flash monitor
    ```
2.  **Interact:**
    The test menu is interactive. Press `Enter` to see the list of tests, then type the test number and `Enter` to run it.
